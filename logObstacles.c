#pragma config(Sensor, dgtl1,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  rightLimit,     sensorTouch)
#pragma config(Sensor, dgtl7,  leftLimit,      sensorTouch)
#pragma config(Sensor, dgtl8,  headEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port4,           headMotor,     tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the obstacle logging behavior
// behavior functions:
//		resetAngleCounter
//    incrementAngleCounter
//    getRange
//    getObstaclePosition
// behavior dependencies:
#include "motorCalibrate.h"
#include "lookBackAndForth.h"
#include "trackHeadAngle.h"
#include "logObstacles.h"

////============ constants =========================
////from logObstacles
//const float ULTRASONIC_DISPLACEMENT = 0.05;//m
//const int N_ANGLES = 20;
//const int MAX_RANGE = 16384;

////============ state timers =========================
////from logObstacles
//int AngleCounter = 0;
//int AngleCounterDelta = 1;

////+++++++++++++++| logObstacles behavior |++++++++++++++++++++++++++++++++
//void resetAngleCounter(int angle_count, int angle_count_delta){
//	AngleCounter = angle_count;
//	AngleCounterDelta =	angle_count_delta;
//}
//void incrementAngleCounter(){
//	AngleCounter += AngleCounterDelta;

//	if(AngleCounter==0){
//		//headHalt();
//		AngleCounterDelta = 1;
//	}
//	if(AngleCounter==N_ANGLES-1){
//		//headHalt();
//		AngleCounterDelta = -1;
//	}
//}

//float getRange(){
//	int range_raw;
//	float range;

//	//get value
//	range_raw = SensorValue[ultrasonic];//cm

//	//check for bad values (usually in wide open spaces)
//	if(range_raw>MAX_RANGE){
//		range_raw = MAX_RANGE;
//	}
//	if(range_raw < 0){
//		range_raw = MAX_RANGE;
//	}

//	//convert to meters
//	range = ((float)range_raw)*0.01;//m

//	return range;
//}

//float* getObstaclePosition(float headAngleWorld,float range,float* pose){
//	float x = pose[0];
//	float y = pose[1];
//	float phi = pose[2];

//	float obstacle_xy[2];
//	obstacle_xy[0] = x + range*cos(headAngleWorld) + ULTRASONIC_DISPLACEMENT*cos(phi);
//	obstacle_xy[1] = y + range*sin(headAngleWorld) + ULTRASONIC_DISPLACEMENT*sin(phi);

//	return obstacle_xy;
//}

task main()
{
	// pose ===========================================================
	float pose[3];
	float* pose_ptr = &pose;
	float x=0,y=0,phi=0;
	pose[0]=x;pose[1]=y;pose[2]=phi;

	// speeds =========================================================
	float w_look = 0.0;
	float w_head = 0.0;

	// logObstacle behavior ===========================================
	// obstacle log
	float obstacles_xy[N_ANGLES][2];
	for(int i=0; i<N_ANGLES; i++){
		obstacles_xy[i][0]=10.0;//x
		obstacles_xy[i][1]=10.0;//y
	}
	float* obstacle_ptr;
	float temp_o_x,temp_o_y;

	//ranging
	float range;

	// head tracking
	float halfViewingAngle = headCalibrate();
	float headAngle = 0;

	float angleDelta = 2.0*halfViewingAngle/(float)N_ANGLES;

	float headAngleWorld = 0.0;
	float prevHeadAngleWorld = headAngleWorld-2.0*angleDelta;

	resetAngleCounter(N_ANGLES-1,-1);

	while(1){

		// logObstacle behavior ========================================================================================
		headAngle = getHeadAngle();
		range = getRange();

		headAngleWorld = headAngle-halfViewingAngle+phi;
		if(abs(headAngleWorld - prevHeadAngleWorld) >= angleDelta){
			prevHeadAngleWorld = headAngleWorld;

			obstacle_ptr = getObstaclePosition(headAngleWorld,range,pose);
			temp_o_x = obstacle_ptr[0];temp_o_y = obstacle_ptr[1];

			obstacles_xy[AngleCounter][0] = temp_o_x;
			obstacles_xy[AngleCounter][1] = temp_o_y;

			incrementAngleCounter();
		}
		// end logObstacle behavior ====================================================================================

		w_look = lookBackAndForth(w_look);
		w_head = w_look;
		headRotate(w_head);
	}
}
