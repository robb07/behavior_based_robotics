//#pragma config(Sensor, dgtl1,  ultrasonic,     sensorSONAR_cm)
//#pragma config(Sensor, dgtl6,  rightLimit,     sensorTouch)
//#pragma config(Sensor, dgtl7,  leftLimit,      sensorTouch)
//#pragma config(Sensor, dgtl8,  headEncoder,    sensorQuadEncoder)
//#pragma config(Motor,  port4,           headMotor,     tmotorVex269, openLoop)
////*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the obstacle logging behavior
// behavior functions:
//		resetAngleCounter
//    incrementAngleCounter
//    getRange
//    getObstaclePosition
// behavior dependencies:
//		lookBackAndForth
//    trackHeadAngle

//============ constants =========================
//from logObstacles
const float ULTRASONIC_DISPLACEMENT = 0.05;//m
const int N_ANGLES = 20;
const int MAX_RANGE = 16384;

//============ state timers =========================
//from logObstacles
int AngleCounter = 0;
int AngleCounterDelta = 1;

//+++++++++++++++| logObstacles behavior |++++++++++++++++++++++++++++++++
void resetAngleCounter(int angle_count, int angle_count_delta){
	AngleCounter = angle_count;
	AngleCounterDelta =	angle_count_delta;
}
void incrementAngleCounter(){
	AngleCounter += AngleCounterDelta;

	if(AngleCounter==0){
		//headHalt();
		AngleCounterDelta = 1;
	}
	if(AngleCounter==N_ANGLES-1){
		//headHalt();
		AngleCounterDelta = -1;
	}
}

float getRange(){
	int range_raw;
	float range;

	//get value
	range_raw = SensorValue[ultrasonic];//cm

	//check for bad values (usually in wide open spaces)
	if(range_raw>MAX_RANGE){
		range_raw = MAX_RANGE;
	}
	if(range_raw < 0){
		range_raw = MAX_RANGE;
	}

	//convert to meters
	range = ((float)range_raw)*0.01;//m

	return range;
}

float* getObstaclePosition(float headAngleWorld,float range,float* pose){
	float x = pose[0];
	float y = pose[1];
	float phi = pose[2];

	float obstacle_xy[2];
	obstacle_xy[0] = x + range*cos(headAngleWorld) + ULTRASONIC_DISPLACEMENT*cos(phi);
	obstacle_xy[1] = y + range*sin(headAngleWorld) + ULTRASONIC_DISPLACEMENT*sin(phi);

	return obstacle_xy;
}
