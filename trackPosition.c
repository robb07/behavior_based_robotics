#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  leftEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftMotor,    tmotorVex269, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           rightMotor,     tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the trackPosition behavior
// functions borrowed:
//		angular_wheel_speed_to_power
//    uni_to_diff
//    set_motor_speeds
//    halt
// behavior functions:
//    resetWheelEncoders
//    readWheelEncoders
//    update_odometry
// behavior dependencies:
#include "motorCalibrate.h"
#include "motors.h"
#include "trackPosition.h"

////============ constants =========================
////from trackPosition
//float TICKS_PER_REV = 240.448;
//float m_per_ticks = (2.0*PI*wheel_radius)/TICKS_PER_REV;// m/tick

////+++++++++++++++| functions to estimate pose |++++++++++++++++++++++++++++++++
//void resetWheelEncoders(){
//	//reset the ticks to zero for both
//	SensorValue[rightEncoder] = 0;
//	SensorValue[leftEncoder] = 0;
//}

//float* readWheelEncoders(){
//	float rightTicks;
//	float leftTicks;
//	float ticks[2];
//	//find out how far the wheels have gone
//	// doesn't matter whether third wheel in back or front
//	rightTicks = SensorValue[rightEncoder];
//	leftTicks = -SensorValue[leftEncoder];//needs negative because wheel is reversed
//	ticks[0]=rightTicks;
//	ticks[1]=leftTicks;
//	return ticks;
//}

//float* update_odometry(float* pose,float* ticks,float* prev_ticks){
//	float rightTicks=ticks[0], leftTicks=ticks[1];
//	float prevRightTicks=prev_ticks[0],prevLeftTicks=prev_ticks[1];
//	float d_right,d_left,d_center;
//	float x_dt,y_dt,phi_dt;
//	float x=pose[0],y=pose[1],phi=pose[2];
//	float x_new,y_new,phi_new;
//	float pose_new[3];

//	//transform to distance for right and left wheel plus center of robot
//	d_right = (rightTicks-prevRightTicks)*m_per_ticks;
//	d_left = (leftTicks-prevLeftTicks)*m_per_ticks;
//	d_center = (d_right+d_left)/2.0;

//	//transform into delta's for x, y, and phi
//	x_dt = d_center*cos(phi);
//	y_dt = d_center*sin(phi);
//	phi_dt = (d_right-d_left)/wheel_base;

//	//update state estimate
//	x_new = x+x_dt;
//	y_new = y+y_dt;
//	phi_new = phi+phi_dt;

//	pose_new[0]=x_new;
//	pose_new[1]=y_new;
//	pose_new[2]=phi_new;
//	return pose_new;
//}

task main()
{
	// pose ===========================================================
	float pose[3];
	float* pose_ptr = &pose;
	float x=0,y=0,phi=0;
	pose[0]=x;pose[1]=y;pose[2]=phi;

	// speeds =========================================================
	float v=CRUISE, w=0.5;

	//more state variables for pose ===================================
	float ticks[2];
	float* ticks_ptr;
	float prevTicks[2];
	prevTicks[0]=0;prevTicks[1]=0;

	resetWheelEncoders();

	while(1){
		// update state ================================================================================================
		ticks_ptr = readWheelEncoders();
		ticks[0]=ticks_ptr[0];ticks[1]=ticks_ptr[1];

		pose_ptr = update_odometry(pose,ticks,prevTicks);
		pose[0]=pose_ptr[0];pose[1]=pose_ptr[1];pose[2]=pose_ptr[2];
		x=pose_ptr[0];y=pose_ptr[1];phi=pose_ptr[2];

		//store for next pass
		prevTicks[0] = ticks[0];
		prevTicks[1] = ticks[1];
		// end update state ============================================================================================

		// send actuator commands ======================================================================================
		set_motor_speeds(v,w);

		// end send actuator commands ==================================================================================

	}

}
