//#pragma config(I2C_Usage, I2C1, i2cSensors)
//#pragma config(Sensor, I2C_1,  leftEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
//#pragma config(Sensor, I2C_2,  rightEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
//#pragma config(Motor,  port2,           leftMotor,    tmotorVex269, openLoop, encoder, encoderPort, I2C_1, 1000)
//#pragma config(Motor,  port3,           rightMotor,     tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the trackPosition behavior
// behavior functions:
//    resetWheelEncoders
//    readWheelEncoders
//    update_odometry
// behavior dependencies:
//		motorCalibrate
//		motors

//============ constants =========================
//from trackPosition
float TICKS_PER_REV = 240.448;
float m_per_ticks = (2.0*PI*wheel_radius)/TICKS_PER_REV;// m/tick

//+++++++++++++++| functions to estimate pose |++++++++++++++++++++++++++++++++
void resetWheelEncoders(){
	//reset the ticks to zero for both
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
}

float* readWheelEncoders(){
	float rightTicks;
	float leftTicks;
	float ticks[2];
	//find out how far the wheels have gone
	// doesn't matter whether third wheel in back or front
	rightTicks = SensorValue[rightEncoder];
	leftTicks = -SensorValue[leftEncoder];//needs negative because wheel is reversed
	ticks[0]=rightTicks;
	ticks[1]=leftTicks;
	return ticks;
}

float* update_odometry(float* pose,float* ticks,float* prev_ticks){
	float rightTicks=ticks[0], leftTicks=ticks[1];
	float prevRightTicks=prev_ticks[0],prevLeftTicks=prev_ticks[1];
	float d_right,d_left,d_center;
	float x_dt,y_dt,phi_dt;
	float x=pose[0],y=pose[1],phi=pose[2];
	float x_new,y_new,phi_new;
	float pose_new[3];

	//transform to distance for right and left wheel plus center of robot
	d_right = (rightTicks-prevRightTicks)*m_per_ticks;
	d_left = (leftTicks-prevLeftTicks)*m_per_ticks;
	d_center = (d_right+d_left)/2.0;

	//transform into delta's for x, y, and phi
	x_dt = d_center*cos(phi);
	y_dt = d_center*sin(phi);
	phi_dt = (d_right-d_left)/wheel_base;

	//update state estimate
	x_new = x+x_dt;
	y_new = y+y_dt;
	phi_new = phi+phi_dt;

	pose_new[0]=x_new;
	pose_new[1]=y_new;
	pose_new[2]=phi_new;
	return pose_new;
}
