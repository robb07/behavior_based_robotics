//#pragma config(Sensor, dgtl1,  ultrasonic,     sensorSONAR_cm)
//#pragma config(Sensor, dgtl6,  rightLimit,     sensorTouch)
//#pragma config(Sensor, dgtl7,  leftLimit,      sensorTouch)
//#pragma config(Sensor, dgtl8,  headEncoder,    sensorQuadEncoder)
//#pragma config(I2C_Usage, I2C1, i2cSensors)
//#pragma config(Sensor, I2C_1,  leftEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
//#pragma config(Sensor, I2C_2,  rightEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
//#pragma config(Motor,  port2,           leftMotor,    tmotorVex269, openLoop, encoder, encoderPort, I2C_1, 1000)
//#pragma config(Motor,  port3,           rightMotor,     tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//#pragma config(Motor,  port4,           headMotor,     tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the collide behavior
// behavior functions:
//    checkForCollisions
// behavior dependencies:
//		motors
//    trackPosition
//		lookBackAndForth
//    trackHeadAngle
//    logObstacles


//============ constants =========================
//from collide
const float COLLIDE_DISTANCE = 0.25;//m
const float FRONT_ANGLE = PI/8.0;//rad (22.5 deg)

//+++++++++++++++| collide behavior |++++++++++++++++++++++++++++++++
bool checkForCollisions(float* obs_log, float* pose){
	float u_x_o = 0.0, u_y_o = 0.0, u_mag = 0.0, u_phi = 0.0;

	for(int i=0; i<N_ANGLES; i++){
		u_x_o = obs_log[2*i+0] - pose[0];
		u_y_o = obs_log[2*i+1] - pose[1];
		u_mag = sqrt(u_x_o*u_x_o+u_y_o*u_y_o);
		u_phi = atan2(u_y_o,u_x_o);
		if((u_mag < COLLIDE_DISTANCE) && (abs(pose[2]-u_phi) < FRONT_ANGLE)){
			return true;
		}
	}

	return false;
}
