#pragma config(Sensor, dgtl1,  ultrasonic,     sensorSONAR_cm)
#pragma config(Sensor, dgtl6,  rightLimit,     sensorTouch)
#pragma config(Sensor, dgtl7,  leftLimit,      sensorTouch)
#pragma config(Sensor, dgtl8,  headEncoder,    sensorQuadEncoder)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  leftEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftMotor,    tmotorVex269, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           rightMotor,     tmotorVex269, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           headMotor,     tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the runaway behavior
// behavior functions:
//		calculateRunAway
//    runAwayError
// behavior dependencies:
#include "motorCalibrate.h"
#include "motors.h"
#include "trackPosition.h"
#include "lookBackAndForth.h"
#include "trackHeadAngle.h"
#include "logObstacles.h"
#include "feelForce.h"
#include "runAway.h"
#include "PID.h"

////============ constants =========================
////from runAway
//const float F_RUNAWAY = 1.0;
//const int RUN_AWAY_TIME = 1000;//cycles for the runAway to finish

////============ state timers =========================
////from runAway
//int RunAwayTimer = 0;

////+++++++++++++++| runAway behavior |+++++++++++++++++++++++++++++++++++++
//float calculateRunAway(float f_x, float f_y, float phi_run){
//	float phi_r;

//	//calculate the runaway
//	if(sqrt(f_x*f_x+f_y*f_y) > F_RUNAWAY){
//		phi_r = atan2(f_y,f_x);
//		RunAwayTimer = RUN_AWAY_TIME;//reset the runAway timer
//	}else{
//		phi_r = phi_run;
//	}
//	return phi_r;
//}

//float* runAwayError(float phi_runAway,float phi){
//	float err_v, err_w;

//	//Check the runAway timer
//	if(RunAwayTimer>0){
//		//calculate the translational velocity error signal to send to the PID
//		//scale it based on how inline the robot is with the runAway direction
//		err_v = CRUISE*cos(phi_runAway - phi);

//		//calculate the rotational velocity error signal to send to the PID
//		//scale it based on how much rotation left is needed
//		err_w = phi_runAway - phi;
//		err_w = atan2(sin(err_w),cos(err_w));

//		//decrement runAway timer
//		RunAwayTimer -= 1;
//	}else{
//		//ensure zero state
//		RunAwayTimer = 0;
//		err_v = 0.0;
//		err_w = 0.0;
//	}

//	float err_sig[2];
//	err_sig[0] = err_w;
//	err_sig[1] = err_v;
//	return err_sig;
//}

task main()
{
	// pose ===========================================================
	float pose[3];
	float* pose_ptr = &pose;
	float x=0,y=0,phi=0;
	pose[0]=x;pose[1]=y;pose[2]=phi;

	// speeds =========================================================
	float v=CRUISE, w=0;

	float w_look = 0.0;
	float w_head = 0.0;

	// logObstacle behavior ===========================================
	// obstacle log
	float obstacles_xy[N_ANGLES][2];
	for(int i=0; i<N_ANGLES; i++){
		obstacles_xy[i][0]=10.0;//x
		obstacles_xy[i][1]=10.0;//y
	}
	float* obstacle_ptr;
	float temp_o_x,temp_o_y;

	//ranging
	float range;

	// head tracking
	float halfViewingAngle = headCalibrate();
	float headAngle = 0;

	float angleDelta = 2.0*halfViewingAngle/(float)N_ANGLES;

	float headAngleWorld = 0.0;
	float prevHeadAngleWorld = headAngleWorld-2.0*angleDelta;

	resetAngleCounter(N_ANGLES-1,-1);


	//feelForce
	float* f_ptr;
	float f_x, f_y;

	//runAway
	float phi_runAway = 0.0;
	float* err_runAway_ptr;
	float err_v_runAway = 0.0, err_w_runAway = 0.0;

	//more state variables for pose ===================================
	float ticks[2];
	float* ticks_ptr;
	float prevTicks[2];
	prevTicks[0]=0;prevTicks[1]=0;

	resetWheelEncoders();

	//PID variables
	float e_w_k,e_w_k_old = 0, e_w_I_old=0;
	float e_w_P=0, e_w_I=0, e_w_D=0;
	float e_v_k,e_v_k_old = 0, e_v_I_old=0;
	float e_v_P=0, e_v_I=0, e_v_D=0;

	while(1){
		// update state ================================================================================================
		ticks_ptr = readWheelEncoders();
		ticks[0]=ticks_ptr[0];ticks[1]=ticks_ptr[1];

		pose_ptr = update_odometry(pose,ticks,prevTicks);
		pose[0]=pose_ptr[0];pose[1]=pose_ptr[1];pose[2]=pose_ptr[2];
		x=pose_ptr[0];y=pose_ptr[1];phi=pose_ptr[2];

		//store for next pass
		prevTicks[0] = ticks[0];
		prevTicks[1] = ticks[1];
		// end update state ============================================================================================

		// logObstacle behavior ========================================================================================
		headAngle = getHeadAngle();
		range = getRange();

		headAngleWorld = headAngle-halfViewingAngle+phi;
		if(abs(headAngleWorld - prevHeadAngleWorld) >= angleDelta){
			prevHeadAngleWorld = headAngleWorld;

			obstacle_ptr = getObstaclePosition(headAngleWorld,range,pose);
			temp_o_x = obstacle_ptr[0];temp_o_y = obstacle_ptr[1];

			obstacles_xy[AngleCounter][0] = temp_o_x;
			obstacles_xy[AngleCounter][1] = temp_o_y;

			incrementAngleCounter();
		}
		// end logObstacle behavior ====================================================================================


		// feelForce behavior ==========================================================================================
		f_ptr = feelForce(obstacles_xy,pose);
		f_x = f_ptr[0];f_y = f_ptr[1];
		// end feelForce behavior ======================================================================================

		// runAway behavior ============================================================================================
		phi_runAway = calculateRunAway(f_x,f_y,phi_runAway);

		err_runAway_ptr = runAwayError(phi_runAway,phi);
		err_w_runAway = err_runAway_ptr[0];err_v_runAway = err_runAway_ptr[1];

		// end runAway behavior ========================================================================================

		// send actuator commands ======================================================================================
		//v = err_v_runAway;
		//w = err_w_runAway;

		//compute error signal
		e_w_k = err_w_runAway;
		e_v_k = err_v_runAway;

		//compute PID terms
		e_w_P = e_w_k;
		e_w_I = e_w_I_old + e_w_k*DT;
		e_w_D = (e_w_k - e_w_k_old)/DT;
		e_v_P = e_v_k;
		e_v_I = e_v_I_old + e_v_k*DT;
		e_v_D = (e_v_k - e_v_k_old)/DT;

		//compute new angular velocity
		w = KP*e_w_P +KI*e_w_I +KD*e_w_D;
		//v = KP*e_v_P +KI*e_v_I +KD*e_v_D;
		v = e_v_P;// +KI*e_v_I +KD*e_v_D;
		if(abs(v)>CRUISE){
				if(v>0){
					v = CRUISE;
				}else{
					v = -CRUISE;
				}
	  }

		//save variables for next pass
		e_w_k_old = e_w_k;
		e_w_I_old = e_w_I;
		e_v_k_old = e_v_k;
		e_v_I_old = e_v_I;

		set_motor_speeds(v,w);

		w_look = lookBackAndForth(w_look);
		w_head = w_look;
		headRotate(w_head);

		// end send actuator commands ==================================================================================
	}
}
