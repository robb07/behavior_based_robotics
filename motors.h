//#pragma config(Motor,  port2,           leftMotor,     tmotorVex269, openLoop)
//#pragma config(Motor,  port3,           rightMotor,    tmotorVex269, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//implements the motor behavior
// behavior functions:
//    uni_to_diff
//    set_motor_speeds
//    halt
// behavior dependencies:
//		motorCalibrate

//============ constants =========================
// from motors
float wheel_radius = 0.065;//m (R)
float wheel_base = 0.265;//m (L)

float CRUISE = 0.4;//m/s

//+++++++++++++++| functions to map linear speed to motor controls |+++++++++++

float* uni_to_diff(float linear_speed, float angular_speed){
	//inputs:
	//linear_speed is the forward speed of the robot in m/s
	//angular_speed is the angluar speed (left & right) of the robot in rad/s
	//outputs:
	//angluar_wheel_speeds is a pointer of speeds for the rotation of each wheel in rad/s
	float angluar_wheel_speeds[2];
	float v_r, v_l;

	v_r = (2*linear_speed + angular_speed*wheel_base)/(2*wheel_radius);
	v_l = (2*linear_speed - angular_speed*wheel_base)/(2*wheel_radius);

	angluar_wheel_speeds[0] = v_r;
	angluar_wheel_speeds[1] = v_l;

	return angluar_wheel_speeds;
}

void set_motor_speeds(float linear_speed, float angular_speed){
	float* wheel_speeds;
	wheel_speeds = uni_to_diff(linear_speed, angular_speed);
	float v_r = wheel_speeds[0];
	float v_l = wheel_speeds[1];

	motor[rightMotor] = angular_wheel_speed_to_power(v_r);
  motor[leftMotor]  = angular_wheel_speed_to_power(v_l);
}

void halt(){
  motor[rightMotor] = 0;
  motor[leftMotor]  = 0;
}
